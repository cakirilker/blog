{"componentChunkName":"component---src-templates-post-template-js","path":"/minko","result":{"data":{"markdownRemark":{"html":"<p>Since Angular version 8, we support dynamic imports in <code class=\"language-text\">loadChildren</code> in the route declaration. In this article, I want to give more information about why dynamic imports could be tricky to handle from tooling perspective and why you should be careful with them.</p>\n<p>As engineers, we often have the perception that <code class=\"language-text\">dynamic == good</code>. With statically typed languages, such as TypeScript, this has shifted over the years. Because of compile-time checking, more folks started appreciating what tooling can give us if we provide statically analyzable information at build time.</p>\n<p>In the past, I've heard a lot of complaints around the static imports in JavaScript:</p>\n<blockquote>\n<p>Why does JavaScript restricts us to use only string literals when specifying the module in ES2015 imports?</p>\n</blockquote>\n<p>To see what are the benefits of this, let's look at an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./bar\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Above we have the <code class=\"language-text\">import</code> keyword, import specifier (<code class=\"language-text\">{ foo }</code>), <code class=\"language-text\">from</code> keyword, followed by the <code class=\"language-text\">./bar</code> string literal. There are two great things about this construct:</p>\n<ul>\n<li>Statically we can determine what symbols we import</li>\n<li>Statically we can determine from which module we import</li>\n</ul>\n<h2>Static vs. Dynamic Analysis</h2>\n<p>It's essential to understand what I mean by saying <em>statically</em>. In practice, any correct program can be partially executed at build time (for example, by webpack, <a href=\"https://prepack.io/\">prepack</a>, etc.) and, potentially, fully executed at runtime (if we have sufficient information, and of course, this does not imply that the program will ever terminate). Look at this example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> n <span class=\"token operator\">===</span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If we add a <a href=\"https://prepack.io/\">prepack</a> plugin to our webpack build, the final bundle will look something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Which means that our users will directly see <code class=\"language-text\">5</code> in the console, without having to execute the <code class=\"language-text\">fib</code> function. This is only possible because our program does not use data which is only available at runtime. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fib</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">n</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> n <span class=\"token operator\">===</span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The evaluation of the snippet above would be impossible at build time because we don't know what's the value of <code class=\"language-text\">window.num</code> (imagine we rely on a Chrome extension to set the <code class=\"language-text\">window.num</code> property).</p>\n<p>How does this relate to ES2015 imports? It connects in at least two different ways. With ES2015 imports we can:</p>\n<ul>\n<li>Statically analyze the import specifier when the imported symbols are explicitly listed</li>\n<li>Statically analyze the path because it's a string literal</li>\n</ul>\n<p>Let's suppose for a second that this is a valid syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token function\">getPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The implementation of <code class=\"language-text\">getPath</code> could involve information which is only available at runtime, for example, we can read a property from <code class=\"language-text\">localStorage</code>, send a sync XHR, etc. The ECMAScript standard allows only string literals so that the bundler or the browser, can know the exact location of the module we're importing from.</p>\n<p>Now, let's look at another example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> foo <span class=\"token keyword\">from</span> <span class=\"token string\">\"./foo\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We specify the path as a string literal but we use a wildcard import. In this scenario, in the general case the bundler will be unable to determine which symbols from <code class=\"language-text\">./foo</code> we use in the current module. Imagine we have the following snippet:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// foo.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1.618</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// bar.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> foo <span class=\"token keyword\">from</span> <span class=\"token string\">\"./foo\"</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">[</span>localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If we invoke the bundler by specifying <code class=\"language-text\">bar.js</code> as an entry point, statically we can determine that <code class=\"language-text\">bar.js</code> uses <code class=\"language-text\">a</code> but we have no idea if <code class=\"language-text\">b</code> and <code class=\"language-text\">c</code> are going to be needed at runtime, we don't know what the value of <code class=\"language-text\">localStorage.get(&#39;bar&#39;)</code> is. This way we won't be able to get rid of the unused symbols since we don't know what symbols from <code class=\"language-text\">foo.js</code> its consumers use.</p>\n<p>That's why I often discourage people to use wildcard imports since they could block the bundler from tree-shaking effectively.</p>\n<h2>What about dynamic imports</h2>\n<p>Originally, I started writing this article to explain why dynamic imports could be tricky from a tooling perspective. Let's suppose that we have a lazy-loaded module:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// dynamic.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// foo.js</span>\n<span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./dynamic.js\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If we try to bundle this with rollup by specifying <code class=\"language-text\">foo.js</code> as an entry point we'll get something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ rollup foo.js --output.format esm\n\nfoo.js → stdout<span class=\"token punctuation\">..</span>.\n\n//→ foo.js:\nimport<span class=\"token punctuation\">(</span><span class=\"token string\">'./chunk-75df839a.js'</span><span class=\"token punctuation\">)</span>.then<span class=\"token punctuation\">(</span>m <span class=\"token operator\">=</span><span class=\"token operator\">></span> console.log<span class=\"token punctuation\">(</span>m.a<span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\n\n//→ chunk-75df839a.js:\nconst a <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token builtin class-name\">export</span> <span class=\"token punctuation\">{</span> a <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\ncreated stdout <span class=\"token keyword\">in</span> 59ms</code></pre></div>\n<p>Here's what rollup did:</p>\n<ul>\n<li>Created a chunk from <code class=\"language-text\">foo.js</code>, bundling it with all of its static imports (in this case there are none)</li>\n<li>Statically analyzed <code class=\"language-text\">foo.js</code> and found that it dynamically imports <code class=\"language-text\">dynamic.js</code></li>\n<li>Created another chunk called <code class=\"language-text\">chunk-75df839a.js</code> by bundling together <code class=\"language-text\">dynamic.js</code> with all its static imports (in this case there are none)</li>\n</ul>\n<p>Now let's change something in <code class=\"language-text\">foo.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// foo.js</span>\n<span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./dynamic.js\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In this case, we get:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ rollup foo.js --output.format esm\n\nfoo.js → stdout<span class=\"token punctuation\">..</span>.\nimport<span class=\"token punctuation\">(</span><span class=\"token string\">'./dynamic.js'</span> + <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>.then<span class=\"token punctuation\">(</span>m <span class=\"token operator\">=</span><span class=\"token operator\">></span> console.log<span class=\"token punctuation\">(</span>m.a<span class=\"token punctuation\">))</span><span class=\"token punctuation\">;</span>\ncreated stdout <span class=\"token keyword\">in</span> 39ms</code></pre></div>\n<p>This means that rollup was not able to correctly figure out the entry point of the dynamically loaded chunk. Why? We changed the argument of the import from a string literal to an expression. Same, will happen if we use an expression which could be only evaluated at runtime (for example, <code class=\"language-text\">import(localStorage.getItem(&#39;foo&#39;))</code>). Webpack would handle this case because it'll try to evaluate the expression statically, at build time:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ webpack foo.js\n\nHash: 2a1d2bcb0c5277c3bf29\nVersion: webpack <span class=\"token number\">4.30</span>.0\nTime: 396ms\nBuilt at: 05/11/2019 <span class=\"token number\">3</span>:44:22 PM\n  Asset       Size  Chunks             Chunk Names\n   <span class=\"token number\">1</span>.js  <span class=\"token number\">141</span> bytes       <span class=\"token number\">1</span>  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\nmain.js      <span class=\"token number\">2</span> KiB       <span class=\"token number\">0</span>  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  main\nEntrypoint main <span class=\"token operator\">=</span> main.js\n<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> ./foo.js <span class=\"token number\">58</span> bytes <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">[</span>built<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> ./dynamic.js <span class=\"token number\">21</span> bytes <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">[</span>built<span class=\"token punctuation\">]</span></code></pre></div>\n<h2>Dynamic Imports and TypeScript</h2>\n<p>Now, let's look at another example using TypeScript. Let's suppose we have the following snippet:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// foo.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// bar.ts</span>\n<span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> m<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If we open <code class=\"language-text\">bar.ts</code> in a text editor and we point over <code class=\"language-text\">m.foo</code>, we'll see that it's of type <code class=\"language-text\">number</code>. This means that TypeScript's type inference has tracked the reference and figured out its type. Now, change <code class=\"language-text\">bar.ts</code> to:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// bar.ts</span>\n<span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./foo\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span> <span class=\"token operator\">=></span> m<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>If we point over <code class=\"language-text\">m.foo</code> again, we'll find out that it has type <code class=\"language-text\">any</code> (TypeScript version 3.1.3). Why both differ? When TypeScript finds out that we've passed a string literal to the dynamic import it follows the module reference and performs type inference; if it finds an expression, it fallbacks to type <code class=\"language-text\">any</code>.</p>\n<p>Let's go through a quick recap of our observations:</p>\n<ul>\n<li>In the general case, dynamic imports cannot be tree-shaken because we can access the exported symbols with index signature with an expression that contains data only available at runtime (i.e. <code class=\"language-text\">import(...).then(m =&gt; m[localStorage.getItem(&#39;foo&#39;)])</code>)</li>\n<li>Modern bundlers and TypeScript can resolve dynamic imports only when we have specified the module with a string literal (an exception is webpack, which statically performs partial evaluation)</li>\n</ul>\n<p>This is one of the reasons why in the general case <a href=\"https://blog.mgechev.com/2018/05/09/introducing-guess-js-data-driven-user-experiences-web/\">Guess.js</a>, cannot handle dynamic imports and map them directly to Google Analytics URLs so that it can reuse the predictive model at runtime.</p>\n<h2>Conclusions</h2>\n<p>Dynamic imports are fantastic for code-splitting on a granular level. They allow us to provide lazy-loading boundaries in our application. In the same time, because of their dynamical nature, they often will enable us to sneak in code that requires runtime data for resolution of the imported module, or for accessing its exports.</p>\n<p>In such cases, we should be extremely cautious because we limit the capabilities of the tools that we're using. We sacrifice automatic bundling of lazy-loaded chunks, type inference, and much more.</p>","frontmatter":{"date":"2017-07-12T17:12:33.962Z","formattedDate":"July 12, 2017","path":"/minko","title":"Dynamic imports solve all the problems, right?","tags":["Tooling","JavaScript"]}}},"pageContext":{}}}